//===- LinalgOps.td - Linalg dialect ops -------------------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This is the operation definition file for linear algebra operations.
//
//===----------------------------------------------------------------------===//

#ifndef LINALG_OPS
#define LINALG_OPS

include "mlir/Dialect/Linalg/IR/LinalgBase.td"
include "mlir/Dialect/Linalg/IR/LinalgInterfaces.td"
include "mlir/Interfaces/ControlFlowInterfaces.td"
include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/LoopLikeInterface.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
include "mlir/Interfaces/ViewLikeInterface.td"

// Base class for Linalg dialect ops that do not correspond to library calls.
class Linalg_Op<string mnemonic, list<Trait> traits = []> :
    Op<Linalg_Dialect, mnemonic, traits>;

def Linalg_YieldOp : Linalg_Op<"yield", [Pure, ReturnLike, Terminator]>,
    Arguments<(ins Variadic<AnyType>:$values)> {
  let summary = "Linalg yield operation";
  let description = [{
    `linalg.yield` is a special terminator operation for blocks inside regions
    in `linalg` generic ops. It returns values to the immediately enclosing
    `linalg` generic op.

    Example:

    ```mlir
    linalg.yield %f0, %f1 : f32, f32
    ```
  }];
  let builders = [OpBuilder<(ins), [{ /* nothing to do */ }]>];
  let hasCustomAssemblyFormat = 1;
  let hasVerifier = 1;
}

def Linalg_IndexOp : Linalg_Op<"index", [Pure]>,
    Arguments<(ins ConfinedAttr<I64Attr, [IntMinValue<0>]>:$dim)>,
    Results<(outs Index:$result)> {
  let summary = "linalg index operation";
  let description = [{
    The `linalg.index` operation returns the iteration index of the immediately
    enclosing linalg structured operation for the iteration dimension `dim`. The
    `dim` attribute specifies the position of the accessed dimension in the
    indexing map domain.

    Example:

    ```mlir
    #map = affine_map<(i, j) -> (i, j)>
    linalg.generic {indexing_maps = [#map, #map],
                    iterator_types = ["parallel", "parallel"]}
      outs(%I, %J : memref<?x?xindex>, memref<?x?xindex>) {
      ^bb0(%arg0 : index, %arg1 : index):
      // Access the outer iteration dimension i
      %i = linalg.index 0 : index
      // Access the inner iteration dimension j
      %j = linalg.index 1 : index
      linalg.yield %i, %j : index, index
    }
    ```

    This may lower to IR resembling:

    ```mlir
    %0 = dim %I, %c0 : memref<?x?xindex>
    %1 = dim %I, %c1 : memref<?x?xindex>
    scf.for %i = %c0 to %0 step %c1 {
      scf.for %j = %c0 to %1 step %c1 {
        store %i, %I[%i, %j] : memref<?x?xindex>
        store %j, %J[%i, %j] : memref<?x?xindex>
      }
    }
    ```
  }];

  let assemblyFormat = [{ $dim attr-dict `:` type($result) }];
  let hasVerifier = 1;
}

def Linalg_SoftmaxOp : Linalg_Op<"softmax", [Pure]> {
  let arguments = (ins AnyTensor:$input,
                       I64Attr:$dim);
  let results = (outs AnyTensor:$result);
  let summary = "linalg softmax operation";
  let description = [{
    This implements the softmax operator.
  }];
  let assemblyFormat = [{ attr-dict `ins``(` $input `:` type($input)`)` `->` type(results) }];
  let hasVerifier = 1;
}

def Linalg_GlobalAveragePool2DOp : Linalg_Op<"globalaveragepool2d", [Pure]> {
  let arguments = (ins AnyTensor:$input);
  let results = (outs AnyTensor:$result);
  let summary = "linalg globalaveragepool2d operation";
  let description = [{
    This implements the globalaveragepool2d operator.
    The custom op is unfused into `linalg.pooling_nchw_sum` and `arith.divf`.
  }];
  let assemblyFormat = [{ attr-dict `ins``(` $input `:` type($input)`)` `->` type(results) }];
  let hasVerifier = 1;
}

def Linalg_SubgraphOp
    : Linalg_Op<"subgraph", [
        IsolatedFromAbove,
        DeclareOpInterfaceMethods<MemoryEffectsOpInterface>,
        DeclareOpInterfaceMethods<LinalgOperatorClassInterface>,
        DeclareOpInterfaceMethods<
          RegionBranchOpInterface, [
            "getSuccessorEntryOperands",
            "getNumRegionInvocations",
            "getRegionInvocationBounds"]>,
        SingleBlockImplicitTerminator<"YieldOp">]> {
  let summary = "Fused operator region";
  let description = [{
    The `linalg.subgraph` operation declares a single block that collects
    operations that produce a tensor value in a single region, with
    all intermediary values being buffered internally and/or scalar replaced.

    All values used within this block must be explicitly captured.

    This operation also supports buffered semantics, where no value will be
    returned, and all side-effects are expected to be mediated through captured
    memrefs.

    Example:

    ```mlir
    %0 = ... : tensor<1x3x108x108xf32>
    %1 = linalg.subgraph (%ifm = %0 : tensor<1x3x108x108xf32>) {
      %0 = linalg.conv2d_nchw ins(%ifm: ...
      %1 = linalg.relu2d_nchw ins(%0: ...
      linalg.yield %1 : tensor<1x3x106x106xf32>
    } -> tensor<1x3x106x106xf32>
    ```
  }];

  let arguments = (ins Variadic<AnyType>:$captures);
  let results = (outs Optional<AnyRankedTensor>:$result);
  let regions = (region SizedRegion<1>:$body);

  let hasCustomAssemblyFormat = 1;
  let hasVerifier = 1;
  let hasCanonicalizer = 1;

  let builders = [
    OpBuilder<(ins
      "Type":$resultType,
      "ValueRange":$captures,
      CArg<"function_ref<void(OpBuilder &, Location, BlockAndValueMapping &)>", "nullptr">:$bodyBuilder)>,
    OpBuilder<(ins
      "ValueRange":$captures,
      CArg<"function_ref<void(OpBuilder &, Location, BlockAndValueMapping &)>", "nullptr">:$bodyBuilder)>
  ];
  let skipDefaultBuilders = 1;

  code extraClassDeclaration = [{
    Block::BlockArgListType getCaptureArgs() {
      return getBody().getArguments();
    }

    BlockAndValueMapping getCaptureMapping() {
      BlockAndValueMapping result;
      for (unsigned idx = 0; idx < getCaptures().size(); ++idx) {
        result.map(getCaptures()[idx], getCaptureArgs()[idx]);
      }
      return result;
    }
    BlockAndValueMapping getUnCaptureMapping() {
      BlockAndValueMapping result;
      for (unsigned idx = 0; idx < getCaptures().size(); ++idx) {
        result.map(getCaptureArgs()[idx], getCaptures()[idx]);
      }
      return result;
    }
  }];
}

#endif // LINALG_OPS
